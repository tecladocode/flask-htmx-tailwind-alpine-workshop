{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Welcome to this workshop on Rapid Development with Flask, HTMX, TailwindCSS, and AlpineJS.</p> <p>This workshop was first delivered as part of FlaskCon 2023. Check out the official site at https://flaskcon.com.</p> <p>The workshop recording is currently unavailable but will be available very soon!</p> <p>If you want to learn more about Python, web develpment, REST APIs, and more, check out our courses at https://teclado.com.</p> <p>Enjoy the workshop! Get started with the first step.</p>"},{"location":"01-index/","title":"Rapid Project Setup","text":"<p>This idea of rapid development isn't necessarily the \"best\" way to do anything. But it is definitely a rapid way of doing things.</p> <p>What I'll show you is how you can very quickly develop a server-side application that is dynamic, usable, simple, and (in my opinion) joyful to work with.</p> <p>As your application grows and becomes more complex, this way of developing, and indeed the whole application you've already developed using this method, may need re-written.</p> <p>This is ideal for prototypes, side projects that you want to get out there quickly, internal tools, etc. If you're not careful, the code ends up becoming a bit messy. But at that point, your idea will be validated. You'll have customers or users, and you can spend time finessing your approach and your code.</p> <p>By doing things this way I've implemented relatively complex interfaces in minutes or hours, instead of days.</p>"},{"location":"01-index/#rapid-project-set-up","title":"Rapid project set-up","text":"<p>Python packaging! We love it dearly. To get started quickly, I recommend using Rye:</p> <pre><code>rye init flask-htmx-tailwind\ncd flask-htmx-tailwind\nrye pin 3.12\n</code></pre> <p>With these three commands you create your project folder, set up your virtual environment, set your Python version (and install it if you don't have it already).</p> <p>To install requirements, either add them to <code>pyproject.toml</code>, or use <code>rye add</code>:</p> <pre><code>rye add \"flask[dotenv]\" jinja-partials feedparser\nrye sync\n</code></pre> <p>Then to run your Flask app you just do:</p> <pre><code>rye run flask run\n</code></pre> <p>You can also activate the <code>.venv</code> and run <code>flask run</code> as usual.</p> <p>It's worth learning about Docker and docker-compose so you can run your app with that (and run a database alongside it), but for now this is good enough!</p>"},{"location":"01-index/#adding-dependencies","title":"Adding dependencies","text":""},{"location":"01-index/#adding-tailwindcss","title":"Adding TailwindCSS","text":"<p>There are many ways to run TailwindCSS when you run your Flask app, but for the speediest workflow, let's just use the CDN version of TailwindCSS. This means that we don't have to worry about compiling our CSS, and we can just use TailwindCSS classes in our HTML.</p> <p>Add the TailwindCSS CDN to the <code>&lt;head&gt;</code> of your <code>base.html</code> template:</p> <pre><code>&lt;script src=\"https://cdn.tailwindcss.com\"&gt;&lt;/script&gt;\n</code></pre> <p>The CDN version of TailwindCSS contains all of the classes, so it isn't recommended for production applications. Instead, you should install <code>tailwindcss</code> with npm, and run it on your HTML files with <code>--minify</code> to create a smaller CSS file.</p>"},{"location":"01-index/#using-tailwindcss-with-npm","title":"Using TailwindCSS with npm","text":"<p>See https://tailwindcss.com/docs/installation.</p>"},{"location":"01-index/#adding-htmx","title":"Adding HTMX","text":"<p>Add the HTMX CDN to the <code>&lt;head&gt;</code> of your <code>base.html</code> template:</p> <pre><code>&lt;script src=\"https://unpkg.com/htmx.org@1.9.9\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"01-index/#adding-alpinejs","title":"Adding AlpineJS","text":"<p>HTMX is fantastic because it allows you to perform server requests, receive responses, and replace parts of your HTML, without reloading the page.</p> <p>However, sometimes we just need to add some in-page interactivity.</p> <p>AlpineJS is perfect for the job. It pairs very well with HTMX and is very lightweight.</p> <pre><code>&lt;script src=\"https://unpkg.com/alpinejs\" defer&gt;&lt;/script&gt;\n</code></pre>"},{"location":"02-partials-vs-components/","title":"Partials vs. Components?","text":"<p>Jinja has the concept of \"macro\" and \"include\". Both of these can be used to bring in another template or part of a template into the current template.</p> <p>However, macros can't be rendered using render_template, and includes can't take arbitrary arguments.</p> <p>Jinja partials solves this by allowing us to define renderable templates (so they can be rendered and returned by a Flask endpoint), but also we can render them within other templates and pass arbitrary arguments, like so:</p> <pre><code>{{ render_partial(\"partials/entry.html\", title=item.title) }}\n</code></pre>"},{"location":"03-website-without-reloading/","title":"A Website without Reloading","text":"<p>One of the first things you can add with HTMX is boosted links. These links fetch the target link, and swap the returned HTML by the current page HTML.</p> <p>With these, the page content changes without a page reload, which can make the page seem a bit snappier since there is no blank page in between link clicks.</p> <p>First, let's create our Flask app. Since we don't have a database at the moment, we'll use a dictionary of feed URLs to feeds. Each feed has some attributes, as well as a dictionary of entries (mapping entry URL to entry body).</p> <p>When we load the page, we'll go through our feeds and parse their RSS. This is very inefficient. You'd normally want a database, and parse the RSS periodically. It'll do the job for showing you how this all works.</p> __init__.py<pre><code>import feedparser\nimport jinja_partials\nfrom flask import Flask, render_template\n\nfeeds = {\n    \"https://blog.teclado.com/rss/\": {\"title\": \"The Teclado Blog\", \"href\": \"https://blog.teclado.com/rss/\", \"show_images\": True, \"entries\": {}},\n    \"https://www.joshwcomeau.com/rss.xml\": {\"title\": \"Josh W. Comeau\", \"href\": \"https://www.joshwcomeau.com/rss.xml\", \"show_images\": False, \"entries\": {}},\n}\n\ndef create_app():\n    app = Flask(__name__)\n    jinja_partials.register_extensions(app)\n\n\n    @app.route(\"/feed/\")\n    @app.route(\"/feed/&lt;path:feed_url&gt;\")\n    def render_feed(feed_url: str = None):\n        for url, feed_ in feeds.items():\n            parsed_feed = feedparser.parse(url)\n            for entry in parsed_feed.entries:\n                if entry.link not in feed_[\"entries\"]:\n                    feed_[\"entries\"][entry.link] = entry\n\n        if feed_url is None:\n            feed = list(feeds.values())[0]\n        else:\n            feed = feeds[feed_url]\n        return render_template(\"feed.html\", feed=feed, feeds=feeds)\n\n\n    return app\n</code></pre> <p>Note</p> <p>The way of updating the entries of a feed is over-complicated, but we need this logic for later on. At the moment, you could just do this:</p> <pre><code>for url in feeds:\n    parsed_feed = feedparser.parse(url)\n    feeds[url] = parsed_feed\n</code></pre> <p>But we'll be adding some custom data to entries later, so we don't want to overwrite all the entries each time. That's why we're only adding new entries, and not those that already exist.</p>"},{"location":"03-website-without-reloading/#setting-up-the-base-template","title":"Setting up the base template","text":"<p>In the base template we'll want to include our dependencies: TailwindCSS and HTMX.</p> <p>We'll also set up the <code>content</code> block where other templates can put their content.</p> templates/base.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Feed reader&lt;/title&gt;\n        &lt;script src=\"https://cdn.tailwindcss.com?plugins=typography,aspect-ratio\"&gt;&lt;/script&gt;\n        &lt;script src=\"https://unpkg.com/htmx.org@1.9.9\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        {% block content %}\n        {% endblock content %}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"03-website-without-reloading/#our-partials-for-entry-and-entry-page","title":"Our partials for entry and entry page","text":"<p>One entry will represent one article in the RSS feed we're reading:</p> templates/partials/entry.html<pre><code>{#\nA rendered summarized entry\n- title\n- published\n- summary\n- media_content (post image)\n- author\n- link\n#}\n&lt;article class=\"grid grid-cols-[300px_600px] mb-4\"&gt;\n    {% if media_content %}\n        &lt;img class=\"aspect-video rounded-md shadow-md\"\n             src=\"{{ media_content[0]['url'] }}\" /&gt;\n    {% endif %}\n    &lt;div class=\"ml-8 pt-4 {{ 'col-start-2' if media_content else 'col-start-1 col-span-2' }}\"&gt;\n        &lt;h2 class=\"font-bold text-2xl\"&gt;{{ title }}&lt;/h2&gt;\n        &lt;p&gt;\n            Published by &lt;span class=\"font-medium\"&gt;{{ author }}&lt;/span&gt; on &lt;span class=\"font-medium\"&gt;{{ published\n        }}&lt;/span&gt;\n    &lt;/p&gt;\n    &lt;p class=\"leading-6 mb-2\"&gt;{{ summary | safe }}&lt;/p&gt;\n    &lt;a href=\"{{ link }}\" class=\"underline\" target=\"_blank\"&gt;Read article&lt;/a&gt;\n&lt;/div&gt;\n&lt;/article&gt;\n</code></pre> <p>Entries can have images, and they expect a few properties which are named after the <code>feedparser</code> properties for an entry. That way when we parse a feed, we can just pass the entries directly to this template.</p> <p>An entry page is a collection of entries. We don't need to have this as its own partial yet, but it will come in handy when we add pagination.</p> templates/partials/entry_page.html<pre><code>{% for item in entries %}\n  {{ render_partial(\"partials/entry.html\", title=item.title, published=item.published, summary=item.summary,\n    media_content=item.media_content, author=item.author, link=item.link) }}\n{% endfor %}\n</code></pre>"},{"location":"03-website-without-reloading/#the-main-page","title":"The main page","text":"<p>Now that we've got our partials and base template, we can put them together in the main feed page.</p> <p>This has a list of feeds on the left, and the list of entries on the right.</p> templates/feed.html<pre><code>{% extends \"base.html\" %}\n{% block content %}\n  &lt;div class=\"hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col\"&gt;\n    &lt;div class=\"flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 py-4\"&gt;\n      &lt;nav class=\"flex flex-1 flex-col\"&gt;\n        &lt;ul role=\"list\" class=\"flex flex-1 flex-col gap-y-3\"&gt;\n          {% for feed_url, feed_ in feeds.items() %}\n            &lt;li&gt;\n              &lt;a href=\"{{ url_for('render_feed', feed_url=feed_.href) }}\"\n                 hx-boost\n                 class=\"{{ 'bg-green-700 text-white' if feed.href == feed_['href'] else '' }} group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold\"&gt;\n                {{ feed_['title'] }}\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% endfor %}\n        &lt;/ul&gt;\n      &lt;/nav&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"pl-72\"&gt;\n    &lt;main class=\"py-10\"&gt;\n      {% for item in feed[\"entries\"].values() %}\n        {{ render_partial(\"partials/entry.html\", title=item.title, published=item.published, summary=item.summary,\n                media_content=item.media_content, author=item.author, link=item.link) }}\n      {% endfor %}\n      {# {{ render_partial(\"partials/entry_page.html\", entries=entries) }} #}\n    &lt;/main&gt;\n  &lt;/div&gt;\n{% endblock content %}\n</code></pre> <p>With this, we're ready to launch of site and test it out!</p> <pre><code>flask run\n</code></pre>"},{"location":"04-dynamic-pagination/","title":"Simple, dynamic pagination with HTMX","text":"<p>In our earlier application, we rendered the entries directly in the <code>feed.html</code>. Now let's create an endpoint that will render one page of entries using our partial.</p> <p>Warning</p> <p>When we get an RSS feed and parse it using feedparser, that gives us all the entries that are present in the feed. In some cases, it could be dozens or even hundreds of entries.</p> <p>For pagination to be most effective, you'd only load (from your database) the entries for the current page. Since we don't have a database and we're parsing the feeds every time, we don't have the ability to do this. We're \"faking\" the need for pagination at the moment, but it'll show you how it works.</p> <p>This is what the new endpoint looks like:</p> __init__.py<pre><code>import feedparser\nimport jinja_partials\nfrom flask import Flask, abort, render_template, request\n\nfeeds = {\n    \"https://blog.teclado.com/rss/\": {\"title\": \"The Teclado Blog\", \"href\": \"https://blog.teclado.com/rss/\", \"show_images\": True, \"entries\": {}},\n    \"https://www.joshwcomeau.com/rss.xml\": {\"title\": \"Josh W. Comeau\", \"href\": \"https://www.joshwcomeau.com/rss.xml\", \"show_images\": False, \"entries\": {}},\n}\n\ndef create_app():\n    app = Flask(__name__)\n    jinja_partials.register_extensions(app)\n\n\n    @app.route(\"/feed/\")\n    @app.route(\"/feed/&lt;path:feed_url&gt;\")\n    def render_feed(feed_url: str = None):\n        for url, feed_ in feeds.items():\n            parsed_feed = feedparser.parse(url)\n            for entry in parsed_feed.entries:\n                if entry.link not in feed_[\"entries\"]:\n                    feed_[\"entries\"][entry.link] = entry\n\n        if feed_url is None:\n            feed = list(feeds.values())[0]\n        else:\n            feed = feeds[feed_url]\n        return render_template(\"feed.html\", feed=feed, feeds=feeds)\n\n\n    @app.route(\"/entries/&lt;path:feed_url&gt;\")\n    def render_feed_entries(feed_url: str):\n        try:\n            feed = feeds[feed_url]\n        except KeyError:\n            abort(400)\n        page = int(request.args.get(\"page\", 0))\n\n        # Below we're paginating the entries even though\n        # in this application it's not necessary, just to\n        # show what it might look like if it were.\n        return render_template(\n            \"partials/entry_page.html\",\n            entries=list(feed[\"entries\"].values())[page*5:page*5+5],\n            href=feed[\"href\"],\n            page=page,\n            max_page=len(feed[\"entries\"])//5\n        )\n\n\n    return app\n</code></pre> <p>We'll modify the entry page partial to include a button to load the next page of entries. Having the button as part of the page may seem weird, but it's a nice way to ensure that all the data a page needs is colocated. Since a page knows its own page number, it's easy to make a button to get the next page (just add 1).</p> <p>If we stored state outside of the page, then when we render the page, we'd have to keep track of the state elsewhere.</p> templates/partials/entry_page.html<pre><code>{% for item in entries %}\n  {{ render_partial(\"partials/entry.html\", title=item.title, published=item.published, summary=item.summary,\n    media_content=item.media_content, author=item.author, link=item.link) }}\n{% endfor %}\n{% if page &lt; max_page - 1 %}\n  &lt;button hx-get=\"{{ url_for('render_feed_entries', feed_url=href, page=page+1) }}\"\n          hx-swap=\"outerHTML\"\n          hx-target=\"this\"&gt;Load more&lt;/button&gt;\n{% endif %}\n</code></pre> <p>Finally, we can call our new endpoint from <code>feed.html</code> instead of rendering the partial there. Using HTMX, it can call the endpoint and replace the endpoint's response into the element that makes the request:</p> templates/feed.html<pre><code>{% extends \"base.html\" %}\n{% block content %}\n  &lt;div class=\"hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col\"&gt;\n    &lt;div class=\"flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 py-4\"&gt;\n      &lt;nav class=\"flex flex-1 flex-col\"&gt;\n        &lt;ul role=\"list\" class=\"flex flex-1 flex-col gap-y-3\"&gt;\n          {% for feed_url, feed_ in feeds.items() %}\n            &lt;li&gt;\n              &lt;a href=\"{{ url_for('render_feed', feed_url=feed_.href) }}\"\n                 hx-boost\n                 class=\"{{ 'bg-green-700 text-white' if feed.href == feed_['href'] else '' }} group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold\"&gt;\n                {{ feed_['title'] }}\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% endfor %}\n        &lt;/ul&gt;\n      &lt;/nav&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"pl-72\"&gt;\n    &lt;main class=\"py-10\"&gt;\n      &lt;div class=\"px-4 sm:px-6 lg:px-8\"\n           id=\"entries\"\n           hx-get=\"{{ url_for('render_feed_entries', feed_url=feed.href, page=0) }}\"\n           hx-swap=\"afterbegin\"\n           hx-target=\"this\"\n           hx-trigger=\"load\"&gt;&lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/div&gt;\n{% endblock content %}\n</code></pre>"},{"location":"05-adding-feeds/","title":"Adding new RSS feeds","text":"<p>To add new RSS feeds, we need a form!</p> <p>Let's start by creating a partial for it:</p> templates/partials/add_feed.html<pre><code>&lt;form class=\"flex flex-col items-center\" action=\"/add_feed\" method=\"POST\"&gt;\n    &lt;div&gt;\n        &lt;label for=\"url\"&gt;URL&lt;/label&gt;\n        &lt;input type=\"text\" id=\"url\" name=\"url\" class=\"bg-slate-100 p-2 mb-2\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label for=\"title\"&gt;Title&lt;/label&gt;\n        &lt;input type=\"text\" id=\"title\" name=\"title\" class=\"bg-slate-100 p-2 mb-2\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label for=\"showImages\"&gt;Show Images&lt;/label&gt;\n        &lt;input type=\"checkbox\"\n               id=\"showImages\"\n               name=\"showImages\"\n               class=\"bg-slate-100 p-2 mb-2\"&gt;\n    &lt;/div&gt;\n    &lt;input type=\"submit\"\n           value=\"Add\"\n           class=\"bg-slate-600 text-white font-semibold rounded-md px-4 py-2\"&gt;\n&lt;/form&gt;\n</code></pre> <p>Then we can either:</p> <ul> <li>Show the form by calling an endpoint that returns its HTML; or</li> <li>Show the form using JavaScript \ud83d\ude31 (don't worry, AlpineJS is very minimal)</li> </ul>"},{"location":"05-adding-feeds/#adding-feeds-using-htmx","title":"Adding feeds using HTMX","text":"<p>We'll begin by adding two endpoints to our Flask app: one for rendering the form, and one for dealing with the form submission:</p> __init__.py<pre><code>import feedparser\nimport jinja_partials\nfrom flask import Flask, abort, redirect, render_template, request, url_for\n\nfeeds = {\n    \"https://blog.teclado.com/rss/\": {\"title\": \"The Teclado Blog\", \"href\": \"https://blog.teclado.com/rss/\", \"show_images\": True, \"entries\": {}},\n    \"https://www.joshwcomeau.com/rss.xml\": {\"title\": \"Josh W. Comeau\", \"href\": \"https://www.joshwcomeau.com/rss.xml\", \"show_images\": False, \"entries\": {}},\n}\n\ndef create_app():\n    app = Flask(__name__)\n    jinja_partials.register_extensions(app)\n\n\n    @app.route(\"/feed/\")\n    @app.route(\"/feed/&lt;path:feed_url&gt;\")\n    def render_feed(feed_url: str = None):\n        for url, feed_ in feeds.items():\n            parsed_feed = feedparser.parse(url)\n            for entry in parsed_feed.entries:\n                if entry.link not in feed_[\"entries\"]:\n                    feed_[\"entries\"][entry.link] = entry\n\n        if feed_url is None:\n            feed = list(feeds.values())[0]\n        else:\n            feed = feeds[feed_url]\n        return render_template(\"feed.html\", feed=feed, feeds=feeds)\n\n\n    @app.route(\"/entries/&lt;path:feed_url&gt;\")\n    def render_feed_entries(feed_url: str):\n        try:\n            feed = feeds[feed_url]\n        except KeyError:\n            abort(400)\n        page = int(request.args.get(\"page\", 0))\n\n        # Below we're paginating the entries even though\n        # in this application it's not necessary, just to\n        # show what it might look like if it were.\n        return render_template(\n            \"partials/entry_page.html\",\n            entries=list(feed[\"entries\"].values())[page*5:page*5+5],\n            href=feed[\"href\"],\n            page=page,\n            max_page=len(feed[\"entries\"])//5\n        )\n\n    @app.route(\"/add_feed\", methods=[\"POST\"])\n    def add_feed():\n        feed = request.form.get(\"url\")\n        title = request.form.get(\"title\")\n        show_images = request.form.get(\"showImages\")\n        feeds[feed] = {\"title\": title, \"href\": feed, \"show_images\": show_images, \"entries\": {}}\n        return redirect(url_for(\"render_feed\", feed=feed))\n\n    @app.route(\"/render_add_feed\")\n    def render_add_feed():\n        return render_template(\"partials/add_feed.html\")\n\n\n    return app\n</code></pre> <p>Then we'll add a button in our <code>feed.html</code> template that, when clicked, calls the <code>/render_add_feed</code> endpoint and replaces the HTML returned into the current page:</p> templates/feed.html<pre><code>{% extends \"base.html\" %}\n{% block content %}\n  &lt;div class=\"hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col\"&gt;\n    &lt;div class=\"flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 py-4\"&gt;\n      &lt;nav class=\"flex flex-1 flex-col\"&gt;\n        &lt;ul role=\"list\" class=\"flex flex-1 flex-col gap-y-3\"&gt;\n          {% for feed_url, feed_ in feeds.items() %}\n            &lt;li&gt;\n              &lt;a href=\"{{ url_for('render_feed', feed_url=feed_.href) }}\"\n                 hx-boost\n                 class=\"{{ 'bg-green-700 text-white' if feed.href == feed_['href'] else '' }} group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold\"&gt;\n                {{ feed_['title'] }}\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% endfor %}\n        &lt;/ul&gt;\n      &lt;/nav&gt;\n      &lt;div class=\"flex justify-center items-center\"&gt;\n        &lt;button hx-get=\"/render_add_feed\"\n                hx-swap=\"outerHTML\"\n                class=\"bg-slate-600 text-white font-semibold rounded-md px-4 py-2\"&gt;Add&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"pl-72\"&gt;\n    &lt;main class=\"py-10\"&gt;\n      &lt;div class=\"px-4 sm:px-6 lg:px-8\"\n           id=\"entries\"\n           hx-get=\"{{ url_for('render_feed_entries', feed_url=feed.href, page=0) }}\"\n           hx-swap=\"afterbegin\"\n           hx-target=\"this\"\n           hx-trigger=\"load\"&gt;&lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/div&gt;\n{% endblock content %}\n</code></pre> <p>That's it! Doesn't get much easier than that!</p>"},{"location":"05-adding-feeds/#adding-feeds-with-alpinejs","title":"Adding feeds with AlpineJS","text":"<p>If you want to be able to hide the form once you've shown it, then you start needing JavaScript. AlpineJS offers a very minimalistic API that complements HTMX very well.</p> <p>Let's bring it into our base template:</p> templates/base.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Feed reader&lt;/title&gt;\n        &lt;script src=\"https://cdn.tailwindcss.com?plugins=typography,aspect-ratio\"&gt;&lt;/script&gt;\n        &lt;script src=\"https://unpkg.com/htmx.org@1.9.9\"&gt;&lt;/script&gt;\n        &lt;script src=\"https://unpkg.com/alpinejs\" defer&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        {% block content %}\n        {% endblock content %}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Then let's change our <code>feed.html</code> so it uses AlpineJS:</p> templates/feed.html<pre><code>{% extends \"base.html\" %}\n{% block content %}\n  &lt;div class=\"hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col\"&gt;\n    &lt;div class=\"flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 py-4\"&gt;\n      &lt;nav class=\"flex flex-1 flex-col\"&gt;\n        &lt;ul role=\"list\" class=\"flex flex-1 flex-col gap-y-3\"&gt;\n          {% for feed_url, feed_ in feeds.items() %}\n            &lt;li&gt;\n              &lt;a href=\"{{ url_for('render_feed', feed_url=feed_.href) }}\"\n                 hx-boost\n                 class=\"{{ 'bg-green-700 text-white' if feed.href == feed_['href'] else '' }} group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold\"&gt;\n                {{ feed_['title'] }}\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% endfor %}\n        &lt;/ul&gt;\n      &lt;/nav&gt;\n      &lt;div class=\"flex flex-col justify-center items-center\"\n           x-data=\"{show: false}\"&gt;\n        &lt;!-- The below doesn't need to be a partial anymore because we're never rendering it in a Flask endpoint --&gt;\n        &lt;div x-show=\"show\"&gt;{{ render_partial(\"partials/add_feed.html\") }}&lt;/div&gt;\n        &lt;button x-on:click=\"show = !show\"\n                class=\"bg-slate-600 text-white font-semibold rounded-md px-4 py-2\"\n                x-text=\"show ? 'Hide' : 'Show'\"&gt;Show&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"pl-72\"&gt;\n    &lt;main class=\"py-10\"&gt;\n      &lt;div class=\"px-4 sm:px-6 lg:px-8\"\n           id=\"entries\"\n           hx-get=\"{{ url_for('render_feed_entries', feed_url=feed.href, page=0) }}\"\n           hx-swap=\"afterbegin\"\n           hx-target=\"this\"\n           hx-trigger=\"load\"&gt;&lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/div&gt;\n{% endblock content %}\n</code></pre> <p>Here we have the following:</p> <ul> <li><code>x-data=\"{show: false}\"</code> on the button parent.</li> <li>The first child <code>div</code> contains our form, but it's hidden to begin with because <code>x-show=\"show\"</code> will hide it (since <code>show: false</code>).</li> <li>Then there's a button that toggles <code>show</code> with <code>x-on:click=\"show = !show</code>.<ul> <li>The button text changes depending on the <code>show</code> variable, and lets us hide or show the form.</li> </ul> </li> </ul> <p>If we use Alpine, we can get rid of the <code>/render_add_feed</code> template, so that's a small bonus:</p> __init__.py<pre><code>-     \n-     @app.route(\"/render_add_feed\")\n-     def render_add_feed():\n-         return render_template(\"partials/add_feed.html\")\n</code></pre> <p>We could also move <code>add_feed.html</code> outside of <code>partials</code> (since we're no longer rendering it on its own). We could make it a macro. Or we could put the HTML directly in the page. But keeping it as a partial is fine too!</p>"},{"location":"06-read-status/","title":"Entry read status indicator","text":"<p>Let's add some custom data to our entries, akin to what we'd do if we were storing them in a database. Let's add a <code>read</code> status.</p> <p>We'll also add an endpoint for making an entry as read, which then redirects us to the actual entry post.</p> __init__.py<pre><code>import feedparser\nimport jinja_partials\nfrom flask import Flask, abort, redirect, render_template, request, url_for\n\nfeeds = {\n    \"https://blog.teclado.com/rss/\": {\"title\": \"The Teclado Blog\", \"href\": \"https://blog.teclado.com/rss/\", \"show_images\": True, \"entries\": {}},\n    \"https://www.joshwcomeau.com/rss.xml\": {\"title\": \"Josh W. Comeau\", \"href\": \"https://www.joshwcomeau.com/rss.xml\", \"show_images\": False, \"entries\": {}},\n}\n\ndef create_app():\n    app = Flask(__name__)\n    jinja_partials.register_extensions(app)\n\n\n    @app.route(\"/feed/\")\n    @app.route(\"/feed/&lt;path:feed_url&gt;\")\n    def render_feed(feed_url: str = None):\n        for url, feed_ in feeds.items():\n            parsed_feed = feedparser.parse(url)\n            for entry in parsed_feed.entries:\n                if entry.link not in feed_[\"entries\"]:\n                    feed_[\"entries\"][entry.link] = {**entry, \"read\": False}\n\n        if feed_url is None:\n            feed = list(feeds.values())[0]\n        else:\n            feed = feeds[feed_url]\n        return render_template(\"feed.html\", feed=feed, feeds=feeds)\n\n\n    @app.route(\"/entries/&lt;path:feed_url&gt;\")\n    def render_feed_entries(feed_url: str):\n        try:\n            feed = feeds[feed_url]\n        except KeyError:\n            abort(400)\n        page = int(request.args.get(\"page\", 0))\n\n        # Below we're paginating the entries even though\n        # in this application it's not necessary, just to\n        # show what it might look like if it were.\n        return render_template(\n            \"partials/entry_page.html\",\n            entries=list(feed[\"entries\"].values())[page*5:page*5+5],\n            href=feed[\"href\"],\n            page=page,\n            max_page=len(feed[\"entries\"])//5\n        )\n\n    @app.route(\"/add_feed\", methods=[\"POST\"])\n    def add_feed():\n        feed = request.form.get(\"url\")\n        title = request.form.get(\"title\")\n        show_images = request.form.get(\"showImages\")\n        feeds[feed] = {\"title\": title, \"href\": feed, \"show_images\": show_images, \"entries\": {}}\n        return redirect(url_for(\"render_feed\", feed=feed))\n\n    @app.route(\"/feed/&lt;path:feed_url&gt;/entry/&lt;path:entry_url&gt;\")\n    def read_entry(feed_url: str, entry_url: str):\n        feed = feeds[feed_url]\n        entry = feed[\"entries\"][entry_url]\n        entry[\"read\"] = True\n        return redirect(entry_url)\n\n    return app\n</code></pre> <p>Then we'll need to add some stuff to our entry partial as well, to show when an entry has been read or not.</p> <p>We'll start with an icon that denotes the read status. It's just a green circle:</p> <pre><code>&lt;svg viewBox=\"0 0 16 16\"\nxmlns=\"http://www.w3.org/2000/svg\"\nclass=\"fill-emerald-500 h-3 w-3 inline-block mb-1\"&gt;\n    &lt;circle cx=\"8\" cy=\"8\" r=\"8\" /&gt;\n&lt;/svg&gt;\n</code></pre> <p>Now we need to make it so the SVG only shows up if the entry is not read. We can do that with Jinja. Pass the entry's <code>read</code> status to the partial and then just do this:</p> <pre><code>{% if not read %}\n&lt;!-- draw the svg --&gt;\n{% endif %}\n</code></pre> <p>But this will have one problem: when we click on an entry and read it, the app will show it as \"unread\" until we refresh the page. We need a solution that can update the app immediately, as well as update the backend state for when we refresh the page.</p> <p>We can do this with HTMX! But it's one of these things that will be much simpler with JavaScript. So, we go back to AlpineJS.</p> <p>We can add state to the entry <code>div</code>, which is populated from the Jinja value:</p> <pre><code>x-data=\"{ read: {{ read | lower }} }\"\n</code></pre> <p>The <code>{{ read | lower }}</code> portion is a Jinja interpolation. The <code>read</code> value is a Python <code>True</code> or <code>False</code>. We turn it to lowercase so that the final result reads:</p> <pre><code>x-data=\"{ read: true }\n</code></pre> <p>This is valid JavaScript, so with this Alpine stores the boolean value <code>read</code> in the element.</p> <p>Then we can change the link at the bottom to set the Alpine <code>read</code> value to <code>true</code> when we click the link. Here's the complete code, with the elements modified highlighted:</p> templates/partials/entry.html<pre><code>{#\nA rendered summarized entry\n- title\n- published\n- summary\n- media_content (post image)\n- author\n- link\n- read\n- feed_url\n#}\n&lt;article class=\"grid grid-cols-[300px_600px] mb-4\"&gt;\n    {% if media_content %}\n        &lt;img class=\"aspect-video rounded-md shadow-md\"\n             src=\"{{ media_content[0]['url'] }}\" /&gt;\n    {% endif %}\n    &lt;div class=\"ml-8 pt-4 {{ 'col-start-2' if media_content else 'col-start-1 col-span-2' }}\"\n         x-data=\"{ read: {{ read | lower }} }\"&gt;\n        &lt;h2 class=\"font-bold text-2xl\"&gt;\n            &lt;svg x-show=\"!read\"\n                 viewBox=\"0 0 16 16\"\n                 xmlns=\"http://www.w3.org/2000/svg\"\n                 class=\"fill-emerald-500 h-3 w-3 inline-block mb-1\"&gt;\n                &lt;circle cx=\"8\" cy=\"8\" r=\"8\" /&gt;\n            &lt;/svg&gt;\n            {{ title }}\n        &lt;/h2&gt;\n        &lt;p&gt;\n            Published by &lt;span class=\"font-medium\"&gt;{{ author }}&lt;/span&gt; on &lt;span class=\"font-medium\"&gt;{{ published\n        }}&lt;/span&gt;\n    &lt;/p&gt;\n    &lt;p class=\"leading-6 mb-2\"&gt;{{ summary | safe }}&lt;/p&gt;\n    &lt;a x-on:click=\"read = true\"\n       href=\"{{ url_for('read_entry', feed_url=feed_url, entry_url=link) }}\"\n       class=\"underline\"\n       target=\"_blank\"&gt;Read article&lt;/a&gt;\n&lt;/div&gt;\n&lt;/article&gt;\n</code></pre>"},{"location":"07-unread-number-badges/","title":"Updating far away elements","text":"<p>Let's add an unread count to each feed in the sidebar!</p> <p>Adding the unread count initially is relatively straightforward. When we load the page, count how many unread entries there are, and put them on the sidebar beside each feed:</p> templates/feed.html<pre><code>&lt;span&gt;{{ feed_['entries'].values() | rejectattr(\"read\") | list | length }}&lt;/span&gt;\n</code></pre> <p>This is not the simplest bit of code! Using Jinja filters we build an expression that:</p> <ul> <li>Gets the current feed's entries.</li> <li>Rejects those that have <code>read=True</code>.</li> <li>Turns it into a list.</li> <li>Gets the length.</li> </ul> <p>We can put that in a span, and we could style it however we want.</p>"},{"location":"07-unread-number-badges/#updating-without-reloading","title":"Updating without reloading","text":"<p>The main difficulty with this is that when we mark an entry as read, the sidebar won't reload. We also can't use HTMX out-of-band swaps easily, because the endpoint that marks an entry as read redirects the user to a different site.</p> <p>So we go back to AlpineJS, where we'll use event-driven development to achieve this.</p> <p>When we mark an entry as read we're already using AlpineJS to change the state locally:</p> <pre><code>x-on:click=\"read = true\"\n</code></pre> <p>AlpineJS also has event handling, so we can dispatch an event here that can then be caught by the span that contains the number of unread entries.</p> <p>To dispatch an event, we do:</p> <pre><code>x-on:click=\"$dispatch('read'); read = true;\"\n</code></pre> <p>We can include extra data, and we should! A user might click an entry multiple times, so let's include whether the entry has an unread state or not:</p> <pre><code>x-on:click=\"$dispatch('read' { read: read }); read = true;\n</code></pre> <p>There's a lot of <code>read</code> there! In order:</p> <ul> <li><code>'read'</code> is the event name.</li> <li>In <code>{ read: read }</code>, the first <code>read</code> is the name of the key in the object that we are passing.<ul> <li>The second <code>read</code> is the current value of the AlpineJS attribute we're using to store whether an entry has been read or not.</li> </ul> </li> <li>After the semicolon, we change the aforementioned status to <code>true</code>. Nothing to do with the event dispatch.</li> </ul> <p>You could probably write this line of code better than me!</p> <p>Here's the full <code>entry.html</code> code with the changed line highlighted:</p> templates/partials/entry.html<pre><code>{#\nA rendered summarized entry\n- title\n- published\n- summary\n- media_content (post image)\n- author\n- link\n- read\n- feed_url\n#}\n&lt;article class=\"grid grid-cols-[300px_600px] mb-4\"&gt;\n    {% if media_content %}\n        &lt;img class=\"aspect-video rounded-md shadow-md\"\n             src=\"{{ media_content[0]['url'] }}\" /&gt;\n    {% endif %}\n    &lt;div class=\"ml-8 pt-4 {{ 'col-start-2' if media_content else 'col-start-1 col-span-2' }}\"\n         x-data=\"{ read: {{ read | lower }} }\"&gt;\n        &lt;h2 class=\"font-bold text-2xl\"&gt;\n            &lt;svg x-show=\"!read\"\n                 viewBox=\"0 0 16 16\"\n                 xmlns=\"http://www.w3.org/2000/svg\"\n                 class=\"fill-emerald-500 h-3 w-3 inline-block mb-1\"&gt;\n                &lt;circle cx=\"8\" cy=\"8\" r=\"8\" /&gt;\n            &lt;/svg&gt;\n            {{ title }}\n        &lt;/h2&gt;\n        &lt;p&gt;\n            Published by &lt;span class=\"font-medium\"&gt;{{ author }}&lt;/span&gt; on &lt;span class=\"font-medium\"&gt;{{ published\n        }}&lt;/span&gt;\n    &lt;/p&gt;\n    &lt;div class=\"leading-6 mb-2\"&gt;{{ summary }}&lt;/div&gt;\n    &lt;a x-on:click=\"$dispatch('read', {read: read}); read = true;\"\n       href=\"{{ url_for('read_entry', feed_url=feed_url, entry_url=link) }}\"\n       class=\"underline\"\n       target=\"_blank\"&gt;Read article&lt;/a&gt;\n&lt;/div&gt;\n&lt;/article&gt;\n</code></pre>"},{"location":"07-unread-number-badges/#catching-the-event","title":"Catching the event","text":"<p>AlpineJS will bubble up the event upwards through any HTML container that is itself also an AlpineJS component.</p> <p>At the moment, there are no common ancestors of the entry and the sidebar which are AlpineJS components. So there is no way for this event to be caught by the sidebar <code>span</code>.</p> <p>Let's find a common ancestor of entries and the sidebar: the <code>body</code>.</p> <p>We could structure our HTML page a bit better, put everything inside a <code>div</code> and use that. But we've got what we've got, and the <code>body</code> is a fine element.</p> <p>Let's make the <code>body</code> an AlpineJS component so that the event can bubble up to it and be caught by any of its children.</p> <pre><code>&lt;body x-data&gt;\n</code></pre> <p>We don't need to put anything in <code>x-data</code>, just doing this does what we need.</p> <p>Now we can go to the event and add some logic there to catch the event. If the current status of the entry is unread, then we can decrease the number in the badge by 1:</p> <pre><code>&lt;span @read.window=\"{{ '$el.innerHTML -= $event.detail.read ? 0 : 1' if feed.href == feed_['href'] else '' }}\"&gt;{{ feed_['entries'].values() | rejectattr(\"read\") | list | length }}&lt;/span&gt;\n</code></pre> <p>We also need to make sure that we're only decreasing the number in the currently active feed, as that's the only feed in which we could be clicking an article. Otherwise, all feeds would see their unread article count lower.</p> <p>Here's the final code for the feed with changed lines highlighted:</p> templates/feed.html<pre><code>{% extends \"base.html\" %}\n{% block content %}\n  &lt;div class=\"hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col\"&gt;\n    &lt;div class=\"flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 py-4\"&gt;\n      &lt;nav class=\"flex flex-1 flex-col\"&gt;\n        &lt;ul role=\"list\" class=\"flex flex-1 flex-col gap-y-3\"&gt;\n          {% for feed_url, feed_ in feeds.items() %}\n            &lt;li&gt;\n              &lt;a href=\"{{ url_for('render_feed', feed_url=feed_.href) }}\"\n                 hx-boost\n                 class=\"{{ 'bg-green-700 text-white' if feed.href == feed_['href'] else '' }} group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold\"&gt;\n                {{ feed_['title'] }}\n                &lt;span @read.window=\"{{ '$el.innerHTML -= $event.detail.read ? 0 : 1' if feed.href == feed_['href'] else '' }}\"&gt;{{ feed_['entries'].values() | rejectattr(\"read\") | list | length }}&lt;/span&gt;\n              &lt;/a&gt;\n            &lt;/li&gt;\n          {% endfor %}\n        &lt;/ul&gt;\n      &lt;/nav&gt;\n      &lt;div class=\"flex flex-col justify-center items-center\"\n           x-data=\"{show: false}\"&gt;\n        &lt;!-- The below doesn't need to be a partial anymore because we're never rendering it in a Flask endpoint --&gt;\n        &lt;div x-show=\"show\"&gt;{{ render_partial(\"partials/add_feed.html\") }}&lt;/div&gt;\n        &lt;button x-on:click=\"show = !show\"\n                class=\"bg-slate-600 text-white font-semibold rounded-md px-4 py-2\"\n                x-text=\"show ? 'Hide' : 'Show'\"&gt;Show&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"pl-72\"&gt;\n    &lt;main class=\"py-10\"&gt;\n      &lt;div class=\"px-4 sm:px-6 lg:px-8\"\n           id=\"entries\"\n           hx-get=\"{{ url_for('render_feed_entries', feed_url=feed.href, page=0) }}\"\n           hx-swap=\"afterbegin\"\n           hx-target=\"this\"\n           hx-trigger=\"load\"&gt;&lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/div&gt;\n{% endblock content %}\n</code></pre> <p>Note</p> <p><code>@read</code> is the event name, and <code>@read.window</code> makes it so the <code>span</code> can catch the event even if it wasn't emitted by a child component.</p> <p>With this, we're done! We've rapidly built a simple app that is just interactive enough, simple to understand, and very fast to incrementally update.</p> <p>Thank you for reading, and I hope you've enjoyed this session!</p>"}]}